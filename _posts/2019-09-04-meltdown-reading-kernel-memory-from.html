---
layout: post
title: 'Meltdown: Reading Kernel Memory from User Space'
date: '2019-09-04T10:31:00.001-07:00'
author: Karl Taht
tags:
- meltdown
- vulnerability
- security
- spectre
- vuln
- architecture
modified_time: '2019-09-06T14:29:23.385-07:00'
blogger_id: tag:blogger.com,1999:blog-2670908301789336410.post-8646947250806165858
blogger_orig_url: https://researchdoneright.blogspot.com/2019/09/meltdown-reading-kernel-memory-from.html
---

Authors: Mortiz Lipp, Michael Schwarz, Daniel Gruss, et. al<br />Venue: arXiv<br /><br />This paper is one of the massive mainstream security vulnerabilities exposed in 2018 for CPUs. The attack initially was independent of software vulnerabilities, and works even with the presence of KASLR/ASLR. The attack is based off speculative execution, which can result in what they call "transient instructions". These instructions begin execution, but do not finish so there is no change in architectural state. However, their are micro-architectural artifacts, which can be exploited via the Flush+Reload attack methodology. There are three main details worth explaining that are non-trivial:<br /><br />1. Exception handling. When the program attempts to read from kernel memory, this will cause an exception. One way to handle this is via having the exception happen on a separate thread. However, an even more elegant solution is to put the attack in Intel TSX (transactional memory). In this case, an exception is not even raised, we are just notified the transaction fails. However, the micro-architectural state difference will still be present.<br /><br />2. Getting into kernel code. Prior to this vuln, nearly all operating systems map the kernel into the user space memory in the upper portion of the address space. This allows for faster context switches as you do not have to switch page tables for every system call. By simply indexing into the upper address space, we can gain entry to the kernel.<br /><br />3. Dealing with KASLR. The kernel code is randomized in the address space, however, it is only randomized with 40 bits. Assuming 8GB of memory, there are only 128 probe locations, which is easy enough.<br /><br />The fix: See KAISER / KPTL: Kernel Page Table Isolation. Essentially, we can no longer map the kernel into the address space of user processes.<br /><br /><a href="https://meltdownattack.com/meltdown.pdf">Full Text</a><br /><br />